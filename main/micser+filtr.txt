#include "stm32g4xx.h"
#include <stdint.h>

int current_pwm = 900;

// === SBUS ===
volatile uint16_t rc_channels[16];
volatile uint8_t rx_buffer[25];
volatile uint8_t rx_idx = 0;
volatile uint8_t parser_state = 0;
volatile uint32_t ms = 0;
volatile uint32_t sbus_last_byte_time = 0;

// === SysTick ===
void SysTick_Handler(void)
{
    ms++;
}

static void delay_long(int limit) {
    for (volatile int i = 0; i < limit; i++) __NOP();
}

// === SBUS ДЕКОДЕР ===
void SBUS_Decode(void)
{
    if (rx_buffer[0] != 0x0F || rx_buffer[24] != 0x00)
        return;

    rc_channels[0]  = ((rx_buffer[1]    | rx_buffer[2] << 8)                 & 0x07FF);
    rc_channels[1]  = ((rx_buffer[2]>>3 | rx_buffer[3] << 5)                 & 0x07FF);
    rc_channels[2]  = ((rx_buffer[3]>>6 | rx_buffer[4] << 2 | rx_buffer[5] << 10) & 0x07FF);
    rc_channels[3]  = ((rx_buffer[5]>>1 | rx_buffer[6] << 7)                 & 0x07FF);
    rc_channels[4]  = ((rx_buffer[6]>>4 | rx_buffer[7] << 4)                 & 0x07FF);
    rc_channels[5]  = ((rx_buffer[7]>>7 | rx_buffer[8] << 1 | rx_buffer[9] << 9)  & 0x07FF);
    rc_channels[6]  = ((rx_buffer[9]>>2 | rx_buffer[10] << 6)                & 0x07FF);
    rc_channels[7]  = ((rx_buffer[10]>>5| rx_buffer[11] << 3)                & 0x07FF);
    rc_channels[8]  = ((rx_buffer[12]   | rx_buffer[13] << 8)                & 0x07FF);
    rc_channels[9]  = ((rx_buffer[13]>>3| rx_buffer[14] << 5)                & 0x07FF);
    rc_channels[10] = ((rx_buffer[14]>>6| rx_buffer[15] << 2 | rx_buffer[16] << 10) & 0x07FF);
    rc_channels[11] = ((rx_buffer[16]>>1| rx_buffer[17] << 7)                & 0x07FF);
    rc_channels[12] = ((rx_buffer[17]>>4| rx_buffer[18] << 4)                & 0x07FF);
    rc_channels[13] = ((rx_buffer[18]>>7| rx_buffer[19] << 1 | rx_buffer[20] << 9)  & 0x07FF);
    rc_channels[14] = ((rx_buffer[20]>>2| rx_buffer[21] << 6)                & 0x07FF);
    rc_channels[15] = ((rx_buffer[21]>>5| rx_buffer[22] << 3)                & 0x07FF);
}

// === SBUS UART ===
void LPUART1_SBUS_Init(void)
{
    RCC->AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;
    RCC->APB1ENR2 |= RCC_APB1ENR2_LPUART1EN;

    GPIOA->MODER &= ~(GPIO_MODER_MODE3);
    GPIOA->MODER |=  GPIO_MODER_MODE3_1;
    GPIOA->AFR[0] &= ~(0xF << 12);
    GPIOA->AFR[0] |=  (12 << 12);

    LPUART1->CR1 = 0;
    LPUART1->CR2 = 0;
    LPUART1->CR3 = 0;

    LPUART1->BRR = SystemCoreClock / (100000 / 256);

    LPUART1->CR1 |= USART_CR1_PCE | USART_CR1_PS;
    LPUART1->CR2 |= USART_CR2_RXINV | USART_CR2_STOP_1;

    LPUART1->CR1 |= USART_CR1_RXNEIE;
    LPUART1->CR1 |= USART_CR1_RE | USART_CR1_UE;

    NVIC_EnableIRQ(LPUART1_IRQn);
    NVIC_SetPriority(LPUART1_IRQn, 1);
}

void LPUART1_IRQHandler(void)
{
    if (LPUART1->ISR & USART_ISR_RXNE)
    {
        uint8_t data = (uint8_t)LPUART1->RDR;
        sbus_last_byte_time = ms;

        if (parser_state == 0) {
            if (data == 0x0F) {
                rx_buffer[0] = data;
                rx_idx = 1;
                parser_state = 1;
            }
        } else {
            rx_buffer[rx_idx++] = data;

            if (rx_idx >= 25) {
                SBUS_Decode();
                parser_state = 0;
                rx_idx = 0;
            }
        }
    }

    if (LPUART1->ISR & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE | USART_ISR_PE)) {
        LPUART1->ICR = USART_ICR_ORECF | USART_ICR_NECF |
                       USART_ICR_FECF | USART_ICR_PECF;
    }
}

// === МОТОРЫ ===
void Motors_Init(void) {
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

    GPIOA->MODER &= ~(GPIO_MODER_MODE0 | GPIO_MODER_MODE1);
    GPIOA->MODER |= (GPIO_MODER_MODE0_1 | GPIO_MODER_MODE1_1);
    GPIOA->AFR[0] &= ~((0xF << 0) | (0xF << 4));
    GPIOA->AFR[0] |= ((1 << 0) | (1 << 4));

    GPIOA->MODER &= ~(GPIO_MODER_MODE10 | GPIO_MODER_MODE11);
    GPIOA->MODER |= (GPIO_MODER_MODE10_1 | GPIO_MODER_MODE11_1);
    GPIOA->AFR[1] &= ~((0xF << 8) | (0xF << 12));
    GPIOA->AFR[1] |= ((6 << 8) | (11 << 12));

    TIM2->PSC = 16 - 1;
    TIM2->ARR = 10000 - 1;
    TIM2->CCMR1 = 0x6060;
    TIM2->CCER = 0x11;
    TIM2->CR1 = TIM_CR1_CEN;

    TIM1->PSC = 16 - 1;
    TIM1->ARR = 10000 - 1;
    TIM1->CCMR2 = 0x6060;
    TIM1->CCER = 0x1100;
    TIM1->BDTR |= TIM_BDTR_MOE;
    TIM1->CR1 = TIM_CR1_CEN;
}

void Set_Motors(int val) {
    TIM2->CCR1 = val; // M1
    TIM2->CCR2 = val; // M2
    TIM1->CCR3 = val; // M3
    TIM1->CCR4 = val; // M4
}

// === MAIN ===
int main(void)
{
    RCC->CR |= RCC_CR_HSION;
    while(!(RCC->CR & RCC_CR_HSIRDY));

    SysTick_Config(SystemCoreClock / 1000U);

    LPUART1_SBUS_Init();
    Motors_Init();

    Set_Motors(1000);
    delay_long(6000000);

    uint8_t armed = 0;

    while (1)
    {
        if (ms - sbus_last_byte_time > 30U) {
            parser_state = 0;
            rx_idx = 0;
        }

        uint16_t arm = rc_channels[4];
        armed = (arm > 1500);

        if (!armed) {
            current_pwm = 900;
            Set_Motors(900);
            continue;
        }

        if (current_pwm < 1000)
        {
            current_pwm += 2;
            Set_Motors(current_pwm);
            continue;
        }
  

        // === НОРМАЛИЗАЦИЯ ===
        int thr_raw   = rc_channels[2];
        int roll_raw  = rc_channels[0];
        int pitch_raw = rc_channels[1];
        int yaw_raw   = rc_channels[3];

        
      /* if (thr_raw < 300) {   // _------
            int idle = 1000;
            TIM2->CCR1 = idle;
            TIM2->CCR2 = idle;
            TIM1->CCR3 = idle;
            TIM1->CCR4 = idle;
            continue;
        }                      // ----- */

        const int ROLL_CENTER  = 1020;
        const int PITCH_CENTER = 1022;
        const int YAW_CENTER   = 1011;

        int roll  = roll_raw  - ROLL_CENTER;
        int pitch = -(pitch_raw - PITCH_CENTER);
        int yaw   = yaw_raw   - YAW_CENTER;

        if (roll > -5 && roll < 5) roll = 0;
        if (pitch > -5 && pitch < 5) pitch = 0;
        if (yaw > -5 && yaw < 5) yaw = 0;
        
        int thr = 1000 + (thr_raw - 240) * 1.2;
        if (thr < 1000) thr = 1000;
        if (thr > 2000) thr = 2000;

        
        
                // === LOW-PASS FILTER ===
        static int roll_f = 0;
        static int pitch_f = 0;
        static int yaw_f = 0;

        // α = 0.1 (сильное сглаживание)
        roll_f  = roll_f  * 9 / 10 + roll  / 10;
        pitch_f = pitch_f * 9 / 10 + pitch / 10;
        yaw_f   = yaw_f   * 9 / 10 + yaw   / 10;

        // === МИКСЕР ПОД ТВОЮ СХЕМУ ===
        int m1 = thr + pitch + roll - yaw; // front-left
        int m4 = thr + pitch - roll + yaw; // front-right
        int m2 = thr - pitch + roll + yaw; // rear-left
        int m3 = thr - pitch - roll - yaw; // rear-right

        if (m1 < 1000) m1 = 1000; if (m1 > 2000) m1 = 2000;
        if (m2 < 1000) m2 = 1000; if (m2 > 2000) m2 = 2000;
        if (m3 < 1000) m3 = 1000; if (m3 > 2000) m3 = 2000;
        if (m4 < 1000) m4 = 1000; if (m4 > 2000) m4 = 2000;

        TIM2->CCR1 = m1;
        TIM2->CCR2 = m2;
        TIM1->CCR3 = m3;
        TIM1->CCR4 = m4;
    }
}
